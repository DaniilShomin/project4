{
  "version": 3,
  "sources": ["../../react-if/src/render.tsx", "../../react-if/src/Case.tsx", "../../react-if/src/Default.tsx", "../../react-if/src/Else.tsx", "../../react-if/src/Fallback.tsx", "../../react-if/src/Then.tsx", "../../react-if/src/isThenable.ts", "../../react-if/src/utils.ts", "../../react-if/src/hooks.ts", "../../react-if/src/IfAsync.tsx", "../../react-if/src/getConditionResults.ts", "../../react-if/src/tinyWarning.ts", "../../react-if/src/If.tsx", "../../react-if/src/Switch.tsx", "../../react-if/src/Unless.tsx", "../../react-if/src/When.tsx"],
  "sourcesContent": ["import React, { Fragment } from 'react';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Renders a React component while also checking whether the children are a function or not\n * @param props Props of the component to render\n */\nexport const render: FCWithImplicitChildren = (props) => {\n  if (typeof props.children === 'function') {\n    return <Fragment>{props.children()}</Fragment>;\n  }\n\n  return <Fragment>{props.children || null}</Fragment>;\n};\n", "import type { FC } from 'react';\nimport { render } from './render';\nimport type { ComponentWithConditionPropsWithFunctionChildren } from './types';\n\n/**\n * If the `<Case />` is the first one to have its condition evaluates to true\n * inside the parent `<Switch />` it will be the only rendered.\n * @param props The props to pass down to the `<Case />` component\n */\nexport const Case: FC<ComponentWithConditionPropsWithFunctionChildren> = ({ children = null }) => {\n  return render({ children });\n};\n", "import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * If no `<Case />` have its condition evaluates to true inside the parent `<Switch />`,\n * the first `<Default />` will be the only one rendered.\n * @param props The props to pass down to the `<Default />` component\n */\nexport const Default: FCWithImplicitChildren = ({ children = null }) => {\n  return render({ children });\n};\n", "import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Must only contain a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block.\n * @param props The props to pass down to the `<Else />` component\n */\nexport const Else: FCWithImplicitChildren = (props) => render(props);\n", "import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Must contain only a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block whose condition prop is a promise.\n * @param props The props to pass down to the `<Fallback />` component\n */\nexport const Fallback: FCWithImplicitChildren = (props) => render(props);\n", "import { render } from './render';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * Must contain only a single child, which it renders as-is.\n * Should not be used outside of an `<If />` block.\n * @param props The props to pass down to the `<Then />` component\n */\nexport const Then: FCWithImplicitChildren = (props) => render(props);\n", "/**\n * The MIT License (MIT)\n *\n * Copyright Â© `2020` `The Sapphire Community and its contributors`\n *\n * Source: https://github.com/sapphiredev/utilities/blob/main/packages/utilities/src/lib/isThenable.ts\n * Full license: https://github.com/sapphiredev/utilities/blob/main/LICENSE.md\n */\n\n/* eslint-disable @typescript-eslint/no-unsafe-function-type */\n\ninterface Thenable {\n  then: Function;\n  catch: Function;\n}\n\n/**\n * Verify if the input is a function.\n * @param input The function to verify\n */\n\nexport function isFunction(input: unknown): input is Function {\n  return typeof input === 'function';\n}\n\nfunction hasThen(input: { then?: Function }): boolean {\n  return Reflect.has(input, 'then') && isFunction(input.then);\n}\n\nfunction hasCatch(input: { catch?: Function }): boolean {\n  return Reflect.has(input, 'catch') && isFunction(input.catch);\n}\n\n/**\n * Verify if an object is a promise.\n * @param input The promise to verify\n */\nexport function isThenable(input: unknown): input is Thenable {\n  if (typeof input !== 'object' || input === null) return false;\n  return input instanceof Promise || (input !== Promise.prototype && hasThen(input) && hasCatch(input));\n}\n", "import { isThenable } from './isThenable';\nimport type { CancellablePromise, ExtendablePromise } from './types';\n\n/**\n * Compare two arrays without checking for possible nested properties\n * @param a Array to compare with b\n * @param b Array to compare with a\n * @returns True if arrays are identical, false if they are different\n */\nexport const shallowArraysEqual = (a: any[], b: any[]): boolean => {\n  if (!Array.isArray(a) || !Array.isArray(b)) throw new Error('shallowArraysEqual only accepts arrays as parameters');\n  if (a.length !== b.length) return false;\n\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n};\n\n/**\n * Create a CancellablePromise from a native Promise\n * @param promise The promise object to wrap\n * @returns Return value is an object of type CancellablePromise, with 2 properties:\n * - promise: a promise that can be left pending\n * - cancel: the function to use for cancelling the returned promise\n */\nexport const createCancellablePromise = <T>(promise: ExtendablePromise<T>): CancellablePromise => {\n  if (!isThenable(promise)) {\n    throw new Error('Argument of createCancellablePromise should be a Promise');\n  }\n\n  const isCancelled = { value: false };\n\n  const wrappedPromise: ExtendablePromise<T> = new Promise(async (res, rej) => {\n    try {\n      const d = await promise;\n      if (!isCancelled.value) {\n        res(d);\n      }\n    } catch (error) {\n      if (!isCancelled.value) {\n        rej(error);\n      }\n    }\n  });\n\n  // Forward potential additional properties\n  Object.keys(promise).forEach((key) => {\n    wrappedPromise[key] = promise[key];\n  });\n\n  return {\n    promise: wrappedPromise,\n    cancel: () => {\n      isCancelled.value = true;\n    }\n  };\n};\n", "import { useRef } from 'react';\nimport { shallowArraysEqual } from './utils';\n\n/**\n * Calls a function only once during component lifecycle;\n * When dependency array is provided, will call the function again if at least one of the dependencies changed\n * @param callback The function to execute only once\n * @param dependencies A list of dependencies whose value, if changed since last call,\n * will trigger the execution of the callback\n */\nexport const useSingleton = (callback: () => any, dependencies: any[] = []) => {\n  const hasRan = useRef<boolean>(false);\n  const lastDependencies = useRef<any[]>([]);\n\n  // Parameters type check\n  if (typeof callback !== 'function') {\n    throw new Error(`Incorrect callback parameter for useSingleton hook; expected a function, but got: '${typeof callback}'.`);\n  }\n  if (!Array.isArray(dependencies)) {\n    throw new Error(`Incorrect dependencies parameter for useSingleton; expected an array, but got: '${typeof dependencies}'.`);\n  }\n\n  const hasDependencies = Array.isArray(dependencies) && dependencies.length > 0;\n  if (hasDependencies) {\n    // Has dependencies\n    const hasAnyDependencyChanged = !shallowArraysEqual(lastDependencies.current, dependencies);\n    if (hasAnyDependencyChanged) {\n      // Any dep has changed => overwrite last dependencies and execute callback\n      lastDependencies.current = dependencies;\n    } else if (hasRan.current) {\n      // No dep has changed => same behaviour as if no dependencies\n      return;\n    }\n  } else if (hasRan.current) {\n    // No dependencies\n    return;\n  }\n\n  callback();\n  hasRan.current = true;\n};\n", "import * as React from 'react';\nimport { Fragment, useEffect, useMemo, useRef, useState, type PropsWithChildren, type ReactElement } from 'react';\nimport { Else } from './Else';\nimport { Fallback } from './Fallback';\nimport { Then } from './Then';\nimport { useSingleton } from './hooks';\nimport { isThenable } from './isThenable';\nimport type { AsyncSupportProps, CancellablePromise, ExtendablePromise } from './types';\nimport { createCancellablePromise } from './utils';\n\n/**\n * Props for IfAsync\n */\ninterface Props<T> extends AsyncSupportProps, PropsWithChildren<{ promise: ExtendablePromise<T> }> {}\n\n/**\n * Is included in the `<If />` component, rendered when the condition prop of `<If />` is a Promise;\n * Renders the Fallback component, if contains any, until provided promise is fulfilled;\n * Renders `<Then />` when promise is fulfilled, `<Else />` when rejected\n */\n\nexport function IfAsync<T = any>({ promise, keepAlive = false, children }: Props<T>) {\n  const [isResolved, setIsResolved] = useState<null | boolean>(null);\n  const [returnValue, setReturnValue] = useState(null);\n\n  // Make promise cancellable\n  const cancellablePromise = useMemo((): CancellablePromise => createCancellablePromise(promise), [promise]);\n  const history = useRef<CancellablePromise[]>([]); // Keep history of promises\n\n  // Handle unmount\n  useEffect(() => {\n    return () => {\n      if (!keepAlive) {\n        cancellablePromise.cancel();\n      }\n    };\n  }, [cancellablePromise, cancellablePromise.promise, keepAlive]);\n\n  // Await promise\n  useSingleton(async () => {\n    setIsResolved(null);\n    setReturnValue(null);\n\n    try {\n      const data = await cancellablePromise.promise;\n      setReturnValue(data);\n      setIsResolved(true);\n      history.current.push(cancellablePromise);\n    } catch (error) {\n      setReturnValue(error as any);\n      setIsResolved(false);\n      history.current.push(cancellablePromise);\n    }\n  }, [cancellablePromise.promise]);\n\n  if (!children || !isThenable(promise)) {\n    return null;\n  }\n\n  if (isResolved === null) {\n    // Promise is pending\n    const hasFallback = (React.Children.toArray(children) as ReactElement[]).find((c) => c.type === Fallback);\n    return <Fragment>{hasFallback || null}</Fragment>;\n  }\n\n  if (!isResolved) {\n    // Promise is fulfilled and rejected\n    const hasElse = (React.Children.toArray(children) as ReactElement[]).find((c) => c.type === Else);\n    if (!hasElse) return <Fragment>{null}</Fragment>;\n\n    // Inject caught error\n    let elseElement = hasElse;\n    const hasElseProps = hasElse.props as { children: any };\n    if (typeof hasElseProps.children === 'function') {\n      elseElement = {\n        ...hasElse,\n        props: {\n          ...hasElseProps,\n          children: () => hasElseProps.children(returnValue, history.current, cancellablePromise.promise)\n        }\n      };\n    }\n    return <Fragment>{elseElement}</Fragment>;\n  }\n\n  // Promise is fulfilled and resolved\n  const hasThen = (React.Children.toArray(children) as ReactElement[]).find((c) => c.type === Then);\n  if (!hasThen) return <Fragment>{null}</Fragment>;\n\n  // Inject promise return value\n  let thenElement = hasThen;\n  const hasThenProps = hasThen.props as { children: any };\n  if (typeof hasThenProps.children === 'function') {\n    thenElement = {\n      ...hasThen,\n      props: {\n        ...hasThenProps,\n        children: () => hasThenProps.children(returnValue, history.current, cancellablePromise.promise)\n      }\n    };\n  }\n\n  return <Fragment>{thenElement}</Fragment>;\n}\n", "import type { BooleanLike } from './types';\n\n/**\n * Resolves a condition that is {@link BooleanLike} or returns {@link BooleanLike} from a function\n * @param condition The condition to resolve\n */\nexport const getConditionResult = (condition: BooleanLike | ((...args: unknown[]) => BooleanLike)): boolean => {\n  const conditionResult = Boolean(typeof condition === 'function' ? condition() : condition);\n\n  return conditionResult;\n};\n", "/**\n * Handles errors by throwing them to the console.\n * `__DEV__` is replaced by dts-cli using {@link https://www.npmjs.com/package/babel-plugin-dev-expression babel-plugin-dev-expressions}\n * which will ensure this entire throw is not present in production\n * @param condition The condition to check\n * @param message The message to throw if `condition` resolves to `true`\n */\nexport function tinyWarning(condition: boolean, message: string): asserts condition {\n  if (__DEV__) {\n    if (condition) {\n      // check console for IE9 support which provides console\n      // only with open devtools\n\n      if (typeof console !== 'undefined') {\n        console.warn(message);\n      }\n\n      // Throwing an error and catching it immediately to improve debugging\n      // Users can utilize 'pause on caught exceptions' to get into this throw\n      try {\n        throw new Error(message);\n      } catch (x) {\n        // noop\n      }\n    }\n  }\n}\n\ndeclare global {\n  let __DEV__: boolean;\n}\n", "import React, { Fragment, type FC, type ReactElement } from 'react';\nimport { Else } from './Else';\nimport { Fallback } from './Fallback';\nimport { IfAsync } from './IfAsync';\nimport { Then } from './Then';\nimport { getConditionResult } from './getConditionResults';\nimport { isThenable } from './isThenable';\nimport { tinyWarning } from './tinyWarning';\nimport type { ComponentWithConditionPropsAsyncSupport, ExtendablePromise } from './types';\n\n/**\n * If condition evaluates to true, renders the `<Then />` block will be rendered,\n * otherwise renders the `<Else />` block. Either block may be omitted.\n *\n * This component can contain any number of `<Then />` or `<Else />` blocks,\n * but only the first block of the right type (either Then or Else, depending on the condition) will be rendered.\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nexport const If: FC<ComponentWithConditionPropsAsyncSupport> = ({ condition, keepAlive = false, children }) => {\n  if (!children) {\n    return null;\n  }\n\n  tinyWarning(\n    (!Array.isArray(children) && !((children as ReactElement).type === Else || (children as ReactElement).type === Then)) ||\n      !(React.Children.toArray(children) as ReactElement[]).every((child) => child.type === Else || child.type === Then || child.type === Fallback),\n    'The <If> component should contain <Then /> <Else /> or <Fallback /> components as its children'\n  );\n\n  if (isThenable(condition)) {\n    return (\n      <IfAsync promise={condition as ExtendablePromise<any>} keepAlive={keepAlive}>\n        {children}\n      </IfAsync>\n    );\n  }\n\n  const conditionResult = getConditionResult(condition);\n\n  return <Fragment>{(React.Children.toArray(children) as ReactElement[]).find((c) => (c.type !== Else) !== !conditionResult) || null}</Fragment>;\n};\n", "import * as React from 'react';\nimport { type ReactElement } from 'react';\nimport { Case } from './Case';\nimport { Default } from './Default';\nimport { getConditionResult } from './getConditionResults';\nimport { isFunction } from './isThenable';\nimport type { FCWithImplicitChildren } from './types';\n\n/**\n * It will render the first matching `<Case />`, or the first encountered `<Default />` (or `null`).\n *\n * This component can contain any number of `<Case />` and one `<Default />` blocks\n * @param __namedParameters Children to pass into the `<Switch />` component\n */\nexport const Switch: FCWithImplicitChildren = ({ children }) => {\n  // -- Inspired by react-router --\n\n  // We use React.Children.forEach instead of React.Children.toArray().find()\n  // here because toArray adds keys to all child elements and we do not want\n  // to trigger an unmount/remount for two children <Case>s or <Default>s\n  let matchingCase: ReactElement | undefined = undefined;\n  let defaultCase: ReactElement | undefined = undefined;\n\n  // If the children are a function then resolve it first\n  if (isFunction(children)) {\n    children = children();\n  }\n\n  React.Children.forEach(children, (child) => {\n    // not a valid react child, don't add it\n    /* istanbul ignore next - This is only a safe fail for people writing bad code */\n    if (!React.isValidElement(child)) {\n      return;\n    }\n\n    if (!matchingCase && child.type === Case) {\n      const childProps = child.props as any;\n      const conditionResult = getConditionResult(childProps.condition);\n\n      if (conditionResult) {\n        matchingCase = child;\n      } // else not matching condition, don't add it\n    } else if (!defaultCase && child.type === Default) {\n      defaultCase = child;\n    } // else unknown type, don't add it\n  });\n\n  return matchingCase ?? defaultCase ?? null;\n};\n", "import type { FC } from 'react';\nimport { getConditionResult } from './getConditionResults';\nimport { render } from './render';\nimport type { ComponentWithConditionPropsWithFunctionChildren } from './types';\n\n/** A shorthand for\n *\n * ```jsx\n * <If condition={...}>\n *     <Else>\n *         { ... }\n *     </Else>\n * </If>\n * ```\n *\n * The same rules apply to the child elements as with using the `<Else />` block.\n *\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nexport const Unless: FC<ComponentWithConditionPropsWithFunctionChildren> = ({ condition, children = null }) => {\n  const conditionResult = Boolean(getConditionResult(condition));\n\n  return !conditionResult && children ? render({ children }) : null;\n};\n", "import type { FC } from 'react';\nimport { getConditionResult } from './getConditionResults';\nimport { render } from './render';\nimport type { ComponentWithConditionPropsWithFunctionChildren } from './types';\n\n/** A shorthand for\n *\n * ```jsx\n * <If condition={...}>\n *     <Then>\n *         { ... }\n *     </Then>\n * </If>\n * ```\n *\n * The same rules apply to the child elements as with using the `<Then /`> block.\n *\n * @param __namedParameters The props to pass down to the `<IF />` component, see {@link ComponentWithConditionProps}\n */\nexport const When: FC<ComponentWithConditionPropsWithFunctionChildren> = ({ condition, children = null }) => {\n  const conditionResult = Boolean(getConditionResult(condition));\n\n  return conditionResult && children ? render({ children }) : null;\n};\n"],
  "mappings": "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",
  "names": ["render", "props", "children", "React", "createElement", "Fragment", "Case", "_ref", "_ref$children", "Default", "Else", "Fallback", "Then", "isFunction", "input", "hasThen", "Reflect", "has", "then", "hasCatch", "isThenable", "Promise", "prototype", "shallowArraysEqual", "a", "b", "Array", "isArray", "Error", "length", "i", "createCancellablePromise", "promise", "isCancelled", "value", "wrappedPromise", "_asyncToGenerator", "_regeneratorRuntime", "mark", "_callee", "res", "rej", "d", "wrap", "_callee$", "_context", "prev", "next", "sent", "t0", "stop", "_x", "_x2", "apply", "arguments", "Object", "keys", "forEach", "key", "cancel", "useSingleton", "callback", "dependencies", "hasRan", "useRef", "lastDependencies", "hasDependencies", "hasAnyDependencyChanged", "current", "IfAsync", "_ref$keepAlive", "keepAlive", "_useState", "useState", "isResolved", "setIsResolved", "_useState2", "returnValue", "setReturnValue", "cancellablePromise", "useMemo", "history", "useEffect", "data", "push", "hasFallback", "Children", "toArray", "find", "c", "type", "hasElse", "elseElement", "hasElseProps", "_extends", "thenElement", "hasThenProps", "getConditionResult", "condition", "conditionResult", "Boolean", "tinyWarning", "message", "process", "console", "warn", "x", "If", "every", "child", "Switch", "_ref2", "matchingCase", "undefined", "defaultCase", "isValidElement", "childProps", "Unless", "When"]
}
